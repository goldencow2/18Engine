--Any line proceeded by -- is a lua comment, and can safely be deleted.

--This script is powered by 18Engine, an easy-to-use, all-purpose script for 18xx games.
--https://github.com/goldencow2/18Engine/wiki

USE_SAVES = false
--set this to false while editing your mod or treasuries will persist.
--set this to true, copy in the script, use "save and play" from the modding menu, and then actually save your mod to enable saves (TTS is dumb).
--WARNING: If you intend on modifying any gameOptions, turn use_saves to false first.
---------- As of this writing this should only be an issue for BANK_SIZE.

gameOptions = {

}

gameEntities = {
    OTHER_ACTORS = {
            ['BANK'] = {
                moneyLabelGUID = '',
            },
            ['PRIVATES'] = {
                payPrivatesButtonGUID = ''
            },
            --[[ --Remove this line to use revenue tracker. The values shown are examples.
            ['REVENUE_TRACKER'] = {
                {['GUID']='ff23a4', ['ROWS']=2, ['COLS']=32, ['START']=1,},
                {['GUID']='4b7ea7', ['ROWS']=1, ['COLS']=36, ['START']=65,},
                --etc.
            },
            --]] --Remove this line to use revenue tracker. The values shown are examples.

    }, COMPANIES = {
            ['Example Company'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
                charterGUID = '',
            },

            ['Example Company2'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
                charterGUID = '',
            },

            --- etc.

    }, PLAYERS = {
            ['Red'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
            },

            ['White'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
            },

            --- etc.

    }
}

---VERSION 2.84, copy and paste everything below this line to update!

-----You probably shouldn't edit these unless you know what you're doing.
    -----They can be overwritten by including the option in gameOptions.
gameOptionDefaults = {
    COMPANIES_CAN_FULL_PAY = true,
    COMPANIES_CAN_HALF_PAY = false,

    HALF_PAY_ROUND = 10, --Round the payout of a half-pay to the nearest multiple of this, in favor of the players.
    -- this can be entered as a table, e.g, HALF_PAY_ROUND = {2,5,10} if you are using multiple values for ISSUE_SIZE (see below)

    BANK_SIZE = nil,
    TRANSACTION_LOG_GUID = nil,
    MONEY_SYMBOL = nil,
    MONEY_SYMBOL_POSITION = nil, --'end' to put at end.
    BANK_POOL_SHARES_PAY_COMPANY = false,
    BANK_POOL_ZONE_GUID = nil,
    IPO_SHARES_PAY_COMPANY = false,
    IPO_ZONE_GUID = nil,
    CHARTER_SHARES_PAY_COMPANY = false,

    COMPANIES_CAN_CROSS_INVEST = false,
    COMPANIES_CAN_OWN_OTHER_SHARES = true,
    --Bad wording, kept for backwards compatibility.
    --If COMPANIES_CAN_CROSS_INVEST is set to true for Company A, then Companies B, C, D, etc. can own shares in Company A.
    --If COMPANIES_CAN_OWN_OTHER_SHARES is set to true for Company A, then Company A can own shares in Companies B, C, D, etc. but only if COMPANIES_CAN_CROSS_INVEST is set to true for those companies.
    --If all companies can own shares in all companies, then just set COMPANIES_CAN_CROSS_INVEST to true in global and you're done.
    --If a single company can own shares in any company then set COMPANIES_CAN_CROSS_INVEST to true in global, COMPANIES_CAN_OWN_OTHER_SHARES to false in global, and COMPANIES_CAN_OWN_OTHER_SHARES to true for that one company.

    SHARE_DESCRIPTIONS_ARE_PERCENTAGE = false, --The number appended to a share's description is the % of the revenue it will receive e.g 'B&O20' = 20%, 'UdW5' = 5%
    USE_PRIVATES = false, --If set to true, script excpects you to supply a GUID for an object to stick a "pay privates" button on.
    COMPANIES_CAN_OWN_PRIVATES = true, --if set to false, the script won't ask you to supply charter GUIDs

    COMPANY_CHARTERS_ARE_SHARES = false, --The charter itself represents 1 share.
    --This will also set the company to assume only 1 share exists, and the player who presses the payout button will be paid for it.
    --This also sets the HALF_PAY_ROUND for the company to 1.

    PROPORTIONAL_PAYOUTS = false,
    -- The payout per share will be the total dividend divided by the number of shares paid.
    -- e.g, if only 7 shares are owned by players/companies then the dividend is split 7 ways.
    -- The per share dividend is rounded down before multiplying, with any remainder going to the company unless one player/company owns 100% of the shares.

    ISSUE_SIZE = 10,
    --how many shares the company has. Irrelevant if SHARE_DESCRIPTIONS_ARE_PERCENTAGE is set.
    --If entered as a table, e.g, ISSUE_SIZE = {2,5,10},
    --then a button is created allowing the company to change issue size mid-game, defaulting to the first value listed.

    COMPANY_CREDITS = false,
    -- Companies will not take from or give money to the bank. Only relevant if BANK_SIZE is set.

    COMPANIES_CAN_BANK_TRANSFER = true,
    -- If false, the script won't spawn buttons for "take money" and "spend money"

    --NAME = 'name',
    --! Don't uncomment this, it's documentation. !
    --setting a company's NAME option will print that name in the logs instead of the table name.

    COMPANIES_PAY_FLAT_RATE = false, --Each share earns the amount entered into the counter, instead of dividing the amount between them.
    --If SHARE_DESCRIPTIONS_ARE_PERCENTAGE, then the amount entered is paid for each 10% the owner holds.

    HAND_SHARES_PAY_PLAYER = true, -- if set to false, shares and privates in the players hands will not pay money.

    TRACK_REVENUE = true, --If true, companies will automatically track revenue.
    ADJUST_INPUT_BY_REVENUE = true, -- If true, companies will adjust their input counters automatically when a revenue marker is placed.
    --Both options are ignored if the revenue tracker isn't being used (see documentation).

    TRACK_ON_RIGHT_CLICK = true,
    -- If true, right clicking payout/half-pay will move the corresponding revenue tracker.
    -- If false, left clicking will move it and right clicking will not.

    TRACK_REVENUE_PER_SHARE = false,
    --By default, the automatic revenue tracker assumes revenue is being tracker per-share.
    --E.g, '18' for a 5-share company is a total revenue of $90 but '18' for a 10-share company is a total revenue of $180 and the input counter will be set appropriately.
    --If this is set to true, then the set companies are tracked as if they were 10-shares regardless of size, e.g, placing the tracker down on '18' sets the input counter to $180.

    PRIVATES_USE_GM_NOTES = false, --If set to true, the script will look for the 'Private#' string in the GM Notes field (change your color to black and right click the object)
}

-----YOU DO NOT NEED TO EDIT ANYTHING BELOW THIS LINE-----
SAVE_STATE = {
    versionNumber = 2.84
}

function onSave()
    --saved_data = JSON.encode(gameEntities)
    if not USE_SAVES then
        saved_data = ''
    else
        --bank amount
        SAVE_STATE['Bank Treasury'] = gameEntities.OTHER_ACTORS['BANK'].treasury

        --company treasuries, company issue sizes and issue indicies
        for k,company in pairs(gameEntities.COMPANIES) do
            SAVE_STATE['Company ' .. k] = company.treasury
            if (type(company.ISSUE_SIZE) == 'table') then
                SAVE_STATE['CompanyIS' .. k] = company.issueSize
                SAVE_STATE['CompanyII' .. k] = company.issueIndex
            end

        end

        --player treasuries
        for k,player in pairs(gameEntities.PLAYERS) do
            SAVE_STATE['Player ' .. k] = player.treasury
        end

        saved_data = JSON.encode(SAVE_STATE)
    end
    return saved_data
end

function onload(saved_data)
    if saved_data~='' then
        SAVE_STATE = JSON.decode(saved_data)
    end

    --necessary default crap due to privates copying code from companies.
    if gameOptions.HAND_SHARES_PAY_PLAYER == nil then
        gameOptions.HAND_SHARES_PAY_PLAYER = true
    end

    initCompanies()
    initPlayers()
    initBank()
    initPrivates()
    initLog()
    initIPO()
    initBankPool()
    initRevenue()
end

function initCompanies()
    for k,company in pairs(gameEntities.COMPANIES) do
        --error checking
        if company.moneyLabelGUID then
            if not getObjectFromGUID(company.moneyLabelGUID) then
                broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s moneyLabelGUID.', ERROR_COLOR) return
            end
        end
        if not company.inputCounterGUID then
            broadcastToAll('ERROR: No "inputCounterGUID" entry was found for the ' .. k .. ' Company', ERROR_COLOR) return
        end
        if not getObjectFromGUID(company.inputCounterGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s inputCounterGUID.', ERROR_COLOR) return
        end

        --Copy over or override global options
        for j,v in pairs(gameOptionDefaults) do
            if company[j]==nil then
                if gameOptions[j]==nil then
                    company[j] = v
                else
                    company[j] = gameOptions[j]
                end
            end
        end

        --check for a charter if one is required.
        company.HAS_CHARTER = ( (company.CHARTER_SHARES_PAY_COMPANY) or (company.COMPANIES_CAN_CROSS_INVEST and company.COMPANIES_CAN_OWN_OTHER_SHARES) or (company.USE_PRIVATES and company.COMPANIES_CAN_OWN_PRIVATES) )
        if company.HAS_CHARTER then
            if not company.charterGUID then
                broadcastToAll('ERROR: No "charterGUID" entry was found for the ' .. k .. ' Company', ERROR_COLOR) return
            end
            if not getObjectFromGUID(company.charterGUID) then
                broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s charterGUID.', ERROR_COLOR) return
            end
        end

        company.key = k
        if company.name then company.NAME = company.name end --backwards compatibility
        if not company.NAME then company.NAME = k end
        if not company.shareDescription then company.shareDescription = k end
        --if not company.ISSUE_SIZE then company.issueSize = 10 end

        if (type(company.ISSUE_SIZE) == 'table') then
            --company is capable of being more than one issue size

            --error checking
            if company.SHARE_DESCRIPTIONS_ARE_PERCENTAGE then
                broadcastToAll('ERROR, ' .. k .. ' Company: SHARE_DESCRIPTIONS_ARE_PERCENTAGE is not compatible with multiple issue sizes.', ERROR_COLOR)
            end
            if company.COMPANY_CHARTERS_ARE_SHARES then
                broadcastToAll('ERROR, ' .. k .. ' Company: COMPANY_CHARTERS_ARE_SHARES is not compatible with multiple issue sizes.', ERROR_COLOR)
            end

            if SAVE_STATE['CompanyIS' .. k] then
                company.issueSize = SAVE_STATE['CompanyIS' .. k]
                company.issueIndex = SAVE_STATE['CompanyII' .. k]
            else
                company.issueSize = company.ISSUE_SIZE[1]
                company.issueIndex = 1
            end
        else
            --company has only one issue size
            company.issueSize = company.ISSUE_SIZE
        end

        if (type(company.HALF_PAY_ROUND) == 'table') then

            --error checking
            if not (type(company.ISSUE_SIZE) == 'table') then
                broadcastToAll('ERROR, ' .. k .. ' Company: Multiple values given for HALF_PAY_ROUND but only one value given for ISSUE_SIZE', ERROR_COLOR)
                return
            end

            if #company.ISSUE_SIZE ~= #company.HALF_PAY_ROUND then
                broadcastToAll('ERROR, ' .. k .. ' Company: # of values given for HALF_PAY_ROUND does not match # of values given for ISSUE_SIZE', ERROR_COLOR)
            end

            if SAVE_STATE['CompanyIS' .. k] then
                company.halfPayRound = company.HALF_PAY_ROUND[company.issueIndex]
            else
                company.halfPayRound = company.HALF_PAY_ROUND[1]
            end

        else
            company.halfPayRound = company.HALF_PAY_ROUND
        end

        if SAVE_STATE['Company ' .. k] then
            company.treasury = SAVE_STATE['Company ' .. k]
        else
            company.treasury = 0
        end

        if company.COMPANY_CHARTERS_ARE_SHARES then
            company.issueSize = 2
            company.SHARE_DESCRIPTIONS_ARE_PERCENTAGE = false
            company.halfPayRound = 1
            getObjectFromGUID(company.inputCounterGUID).setName('This Company will pay the player who clicks the button.')
        end

        updateLabel(company)

        --fucking LUA wizardry
        --Using a locally defined function as the click_function allows us to access the other local variables in this for loop

        local btnIndex = 0
        local fullPayIndex = nil
        local halfPayIndex = nil
        --increment as buttons are created, because createButton doesn't return the button's index for some fucking reason.
        --button indexes also start at zero because convention sucks.

        if company.COMPANIES_CAN_HALF_PAY then
            local payFuncName = k .. 'PayHalf'
            local payFunc = function(object, color, alt) buttonHelper(company, 'PayHalf', color, alt) end
            Global.setVar(payFuncName, payFunc)
            payHalfParams.click_function = payFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(payHalfParams)
            halfPayIndex = btnIndex
            btnIndex = btnIndex+1
        end

        if company.COMPANIES_CAN_FULL_PAY then
            local payFuncName = k .. 'Payout'
            local payFunc = function(object, color, alt) buttonHelper(company, 'Payout', color, alt) end
            Global.setVar(payFuncName, payFunc)
            payFullParams.click_function = payFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(payFullParams)
            fullPayIndex = btnIndex
            btnIndex = btnIndex+1
        end

        if company.COMPANIES_CAN_HALF_PAY and company.COMPANIES_CAN_FULL_PAY then
            getObjectFromGUID(company.inputCounterGUID).editButton({index=halfPayIndex, position = addv(payHalfParams.position,{0,0,-0.2})})
            getObjectFromGUID(company.inputCounterGUID).editButton({index=fullPayIndex, label='Pay Full', position = addv(payFullParams.position,{0,0,0.2})})
        end

        if gameEntities.OTHER_ACTORS.REVENUE_TRACKER and company.TRACK_REVENUE then
            --set payout tooltips
            if company.COMPANIES_CAN_FULL_PAY then
                if company.TRACK_ON_RIGHT_CLICK then
                    getObjectFromGUID(company.inputCounterGUID).editButton({index=fullPayIndex, tooltip='Right-click this button to track revenue.'})
                else
                    getObjectFromGUID(company.inputCounterGUID).editButton({index=fullPayIndex, tooltip='Right-click this button to [i]not[/i] track revenue.'})
                end
            end

            if company.COMPANIES_CAN_HALF_PAY then
                if company.TRACK_ON_RIGHT_CLICK then
                    getObjectFromGUID(company.inputCounterGUID).editButton({index=halfPayIndex, tooltip='Right-click this button to track revenue.'})
                else
                    getObjectFromGUID(company.inputCounterGUID).editButton({index=halfPayIndex, tooltip='Right-click this button to [i]not[/i] track revenue.'})
                end
            end
        end

        if (type(company.ISSUE_SIZE) == 'table') then
            local changeSizeFuncName = k .. 'changeSize'
            local changeSizeFunc = function(object, color) changeSize(company) end
            Global.setVar(changeSizeFuncName, changeSizeFunc)
            changeSizeParams.click_function = changeSizeFuncName
            changeSizeParams.label = company.issueSize .. '-Share'
            getObjectFromGUID(company.inputCounterGUID).createButton(changeSizeParams)
            company.changeSizeButtonIndex = btnIndex
            btnIndex = btnIndex+1
        end

        if company.COMPANIES_CAN_BANK_TRANSFER then
            local bankFuncName = k .. 'bankTransfer'
            local bankFunc = function(object, color) buttonHelper(company, 'Bank Transfer') end
            Global.setVar(bankFuncName, bankFunc)
            bankTransferParams.click_function = bankFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(bankTransferParams)
            btnIndex = btnIndex+1

            local withholdFuncName = k .. 'withholdTransfer'
            local withholdFunc = function(object, color) buttonHelper(company, 'Withhold') end
            Global.setVar(withholdFuncName, withholdFunc)
            withholdParams.click_function = withholdFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(withholdParams)
            btnIndex = btnIndex+1
        end
    end
end

function initPlayers()
    for k,player in pairs(gameEntities.PLAYERS) do
        --error checking
        if not player.moneyLabelGUID then
            broadcastToAll('ERROR: No "moneyLabelGUID" entry was found for the ' .. k .. ' Player', ERROR_COLOR) return
        end
        if not getObjectFromGUID(player.moneyLabelGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Player\'s moneyLabelGUID.', ERROR_COLOR) return
        end
        if not player.inputCounterGUID then
            broadcastToAll('ERROR: No "inputCounterGUID" entry was found for the ' .. k .. ' Player', ERROR_COLOR) return
        end
        if not getObjectFromGUID(player.inputCounterGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Player\'s inputCounterGUID.', ERROR_COLOR) return
        end
        if player.shareZoneGUID then
            if not getObjectFromGUID(player.shareZoneGUID) then
                broadcastToAll('ERROR: shareZoneGUID is set and an object could not be found for the ' .. k .. ' Player\'s shareZoneGUID.', ERROR_COLOR) return
            end
        end

        local isValidColor = false;
        for _,c in ipairs(Player.getAvailableColors()) do
            if (k == c) then isValidColor = true end
        end
        if not isValidColor then broadcastToAll('ERROR: Player color ' .. k .. ' is set in gameEntities but no hand zone for ' .. k .. ' was found.', ERROR_COLOR) end

        --okay
        player.key = k
        if Player[k].seated then player.NAME = Player[k].steam_name else player.NAME = k end
        if SAVE_STATE['Player ' .. k] then
            player.treasury = SAVE_STATE['Player ' .. k]
        else
            player.treasury = 0
        end
        updateLabel(player)

        --Using a locally defined function as the click_function allows us to access the other local variables in this for loop
        local bankFuncName = k .. 'bankTransfer'
        local bankFunc = function(object, color) buttonHelper(player, 'Bank Transfer') end
        Global.setVar(bankFuncName, bankFunc)
        bankTransferParams.click_function = bankFuncName
        getObjectFromGUID(player.inputCounterGUID).createButton(bankTransferParams)

        local withholdFuncName = k .. 'withholdTransfer'
        local withholdFunc = function(object, color) buttonHelper(player, 'Withhold') end
        Global.setVar(withholdFuncName, withholdFunc)
        withholdParams.click_function = withholdFuncName
        getObjectFromGUID(player.inputCounterGUID).createButton(withholdParams)
    end
end

function initIPO()
    --if global or any company has IPO_SHARES_PAY_COMPANY, enforce a GUID and fetch bank pool zone
    local usingIPO = gameOptions.IPO_SHARES_PAY_COMPANY
    for k,v in pairs(gameEntities.COMPANIES) do
        usingIPO = usingIPO or v.IPO_SHARES_PAY_COMPANY
    end

    --if using IPO, check to see if the GUID is set.
    if usingIPO then
        if not (gameOptions.IPO_ZONE_GUID) then
            broadcastToAll('IPO_SHARES_PAY_COMPANY is set for at least one company but could not find IPO_ZONE_GUID in gameOptions', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameOptions.IPO_ZONE_GUID) then
            broadcastToAll('ERROR: IPO_ZONE_GUID does not match anything in this mod.', ERROR_COLOR) return
        end

        --error free
        IPO_ZONE = getObjectFromGUID(gameOptions.IPO_ZONE_GUID)
    end
end

function initBankPool()
    --if global or any company has BANK_SHARES_PAY_COMPANY, enforce a GUID and fetch bank pool zone
    local usingBankPool = gameOptions.BANK_POOL_SHARES_PAY_COMPANY
    for k,v in pairs(gameEntities.COMPANIES) do
        usingBankPool = usingBankPool or v.BANK_POOL_SHARES_PAY_COMPANY
    end

    --if using bank pool, check to see if the GUID is set.
    if usingBankPool then
        if not (gameOptions.BANK_POOL_ZONE_GUID) then
            broadcastToAll('BANK_POOL_SHARES_PAY_COMPANY is set for at least one company but could not find BANK_POOL_ZONE_GUID in gameOptions', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameOptions.BANK_POOL_ZONE_GUID) then
            broadcastToAll('ERROR: BANK_POOL_ZONE_GUID does not match anything in this mod.', ERROR_COLOR) return
        end

        --error free
        BANK_POOL_ZONE = getObjectFromGUID(gameOptions.BANK_POOL_ZONE_GUID)
    end
end

function initBank()
    --Check if there should be a bank.
    USE_BANK = gameOptions.BANK_SIZE
    if USE_BANK and not gameEntities.OTHER_ACTORS['BANK'] then broadcastToAll('ERROR: Bank size is non-zero but no "BANK" entry was found in gameEntities.OTHER_ACTORS', ERROR_COLOR) return end

    if USE_BANK then
        --error checking
        if not gameEntities.OTHER_ACTORS['BANK'].moneyLabelGUID then
            broadcastToAll('ERROR: No "moneyLabelGUID" entry was found in gameEntities.OTHER_ACTORS[\'BANK\'].', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameEntities.OTHER_ACTORS['BANK'].moneyLabelGUID) then
            broadcastToAll('ERROR: An object could not be found for the bank\'s moneyLabelGUID.', ERROR_COLOR) return
        end

        --Okay
        if SAVE_STATE['Bank Treasury'] then
            gameEntities.OTHER_ACTORS['BANK'].treasury = SAVE_STATE['Bank Treasury']
        else
            gameEntities.OTHER_ACTORS['BANK'].treasury = gameOptions.BANK_SIZE
        end

        updateLabel(gameEntities.OTHER_ACTORS['BANK'])
    end
end

function initPrivates()
    if gameOptions.USE_PRIVATES and not gameEntities.OTHER_ACTORS['PRIVATES'] then broadcastToAll('ERROR: USE_PRIVATES is set but no "PRIVATES" entry was found in gameEntities.OTHER_ACTORS', ERROR_COLOR) return end

    if gameOptions.USE_PRIVATES then
        --error checking
        if not gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID then
            broadcastToAll('ERROR: No "payPrivatesButtonGUID" entry was found in gameEntities.OTHER_ACTORS[\'PRIVATES\'].', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID) then
            broadcastToAll('ERROR: An object could not be found for the privatess\' payPrivatesButtonGUID.', ERROR_COLOR) return
        end

        --Okay
        getObjectFromGUID(gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID).createButton(payPrivatesParams)
    end
end

function initLog()
    if gameOptions.TRANSACTION_LOG_GUID then
        --error checking
        if not getObjectFromGUID(gameOptions.TRANSACTION_LOG_GUID) then
            broadcastToAll('ERROR: TRANSACTION_LOG_GUID was set but an object with that GUID could not be found.', ERROR_COLOR) return
        end

        --Okay
        TRANSACTION_LOG = getObjectFromGUID(gameOptions.TRANSACTION_LOG_GUID)
        TRANSACTION_LOG.setName('Transaction Log')
        TRANSACTION_LOG.setDescription('')

        TRANSACTIONS = nil
    end
end

function initRevenue()
    if gameEntities.OTHER_ACTORS.REVENUE_TRACKER then
        for _,b in ipairs(gameEntities.OTHER_ACTORS.REVENUE_TRACKER) do
            local box = getObjectFromGUID(b.GUID)
            if box then
                b.valid = true

                local s = box.getScale()
                local s2 = Vector(-s.x/2,-s.y/2,s.z/2)
                b.upperleft = box.getPosition()+s2
                s2 = Vector(s.x/2,-s.y/2,-s.z/2)
                b.lowerright = box.getPosition()+s2
                b.width= b.lowerright.x-b.upperleft.x
                b.height = b.upperleft.z-b.lowerright.z
                b.cellWidth = b.width / b.COLS
                b.cellHeight = b.height / b.ROWS

                if not b.VERTICAL_INC then b.VERTICAL_INC = b.COLS end

                b.maxValue = b.START + b.COLS-1 + b.VERTICAL_INC * (b.ROWS-1)
            end
        end
    end
end

function buttonHelper(caller, type, color, alt)
    local amount = getObjectFromGUID(caller.inputCounterGUID).getValue()
    if amount == 0 then return end
    if type == 'Bank Transfer' then
        amount = amount*-1
        transferMoneyWithBank(caller, amount, true, true)
    elseif type == 'Payout' then
        Payout(caller, amount, color)
    elseif type == 'Withhold' then
        Withhold(caller, amount)
    elseif type == 'PayHalf' then
        printToAll('')
        if (amount > 0) then
            Payout(caller, roundTo(amount/2, caller.halfPayRound, true), color)
            Withhold(caller, roundTo(amount/2, caller.halfPayRound, false), color)
        else
            Payout(caller, roundTo(amount/2, caller.halfPayRound, false), color)
            Withhold(caller, roundTo(amount/2, caller.halfPayRound, true), color)
        end
    end

    --move revenue tracker
    if gameEntities.OTHER_ACTORS.REVENUE_TRACKER and caller.TRACK_REVENUE and alt~=nil then
        if not caller.TRACK_ON_RIGHT_CLICK then alt = not alt end
        if alt then
            --find appropriate box
            local num = 0
            if caller.TRACK_REVENUE_PER_SHARE then num = math.floor(amount/caller.issueSize) else num = amount/10 end
            for _,b in ipairs(gameEntities.OTHER_ACTORS.REVENUE_TRACKER) do
                if num>=b.START and num<=b.maxValue and (num-b.START)%b.VERTICAL_INC>=0 and (num-b.START)%b.VERTICAL_INC<=b.COLS-1 then
                    local xcell = (num-b.START) % (b.VERTICAL_INC)
                    local zcell = math.floor((num-b.START) / b.VERTICAL_INC)
                    local obj = getObjectFromGUID(caller['revenueTrackerGUID'])
                    if (obj) then
                        obj.setPositionSmooth({b.upperleft.x + b.cellWidth*(xcell+0.5), obj.getPosition().y+1, b.upperleft.z - b.cellHeight*(zcell+0.5)}, false, true)
                    else
                        broadcastToColor("Automatic tracking requires the first value to be placed manually.", color, 'Red')
                    end
                    break
                end
            end
        end
    end
end

function transferMoneyWithBank(caller, amount, print, log)
    --print = boolean, print to all chat?
    --log = boolean, print to the log object?
    caller.treasury = caller.treasury + amount
    updateLabel(caller)
    if USE_BANK and not caller.COMPANY_CREDITS then
        gameEntities.OTHER_ACTORS['BANK'].treasury = gameEntities.OTHER_ACTORS['BANK'].treasury - amount
        updateLabel(gameEntities.OTHER_ACTORS['BANK'])
    end
    if (amount > 0) then
        logTransaction(amount, 'Bank', caller.NAME, print, log)
    elseif (amount < 0) then
        logTransaction(amount*-1, caller.NAME, 'Bank', print, log)
    end
end

function Withhold(caller, amount)
    transferMoneyWithBank(caller, amount, true, true)
end

function Payout(caller, amount, color)
    local payoutTable = {}
    --Part of this function spawns ScriptingZones, which take more than one frame to load.
    --The waitFlags are used to make sure all ScriptingZones have loaded and done their thing before continuing.

    local waitFlags = {}

    if caller.COMPANY_CHARTERS_ARE_SHARES then
        payoutTable[color] = {gameEntities.PLAYERS[color], 2}
    else

        --tabulate player shares
        for k,v in pairs(gameEntities.PLAYERS) do
            payoutTable[k] = {v, 0}
            --if player has a designated zone, search that for shares matching this company
            if getObjectFromGUID(v.shareZoneGUID) then
                if getObjectFromGUID(v.shareZoneGUID).tag == 'Scripting' then
                    payoutTable[k][2] = searchContainer(getObjectFromGUID(v.shareZoneGUID).getObjects(), caller, payoutTable[k][2])
                else

                    waitFlags[k] = false

                    --Dynamically spawn a scripting zone to on the charter
                    local bb = getObjectFromGUID(v.shareZoneGUID).getBoundsNormalized()
                    local params = {}
                    local callbackName = "callbackPlayer" .. k
                    params.position = getObjectFromGUID(v.shareZoneGUID).getPosition()
                    params.rotation = getObjectFromGUID(v.shareZoneGUID).getRotation()
                    params.scale = { bb.size.x, bb.size.y+8, bb.size.z }
                    params.callback = callbackName
                    params.type = 'ScriptingTrigger'
                    params.sound = false
                    local zone = spawnObject(params)

                    local callbackFunc = function()
                        payoutTable[k][2] = searchContainer(zone.getObjects(), caller, payoutTable[k][2])
                        waitFlags[k] = true
                        zone.destruct()
                    end
                    Global.setVar(callbackName, callbackFunc)

                end
            end
            --search the player's hand
            if caller.HAND_SHARES_PAY_PLAYER then
                payoutTable[k][2] = searchContainer(Player[k].getHandObjects(), caller, payoutTable[k][2])
            end
        end

        --tabulate company shares
            payoutTable[caller.key] = {caller, 0}
            --bank pool
            if caller.BANK_POOL_SHARES_PAY_COMPANY then
                payoutTable[caller.key][2] = searchContainer(BANK_POOL_ZONE.getObjects(), caller, payoutTable[caller.key][2])
            end
            --IPO
            if caller.IPO_SHARES_PAY_COMPANY then
                payoutTable[caller.key][2] = searchContainer(IPO_ZONE.getObjects(), caller, payoutTable[caller.key][2])
            end
            --Charter
            if caller.CHARTER_SHARES_PAY_COMPANY then
                waitFlags[caller.key] = false

                --Dynamically spawn a scripting zone to on the charter
                local bb = getObjectFromGUID(caller.charterGUID).getBoundsNormalized()
                local params = {}
                local callbackName = "callback" .. caller.key
                params.position = getObjectFromGUID(caller.charterGUID).getPosition()
                params.rotation = getObjectFromGUID(caller.charterGUID).getRotation()
                params.scale = { bb.size.x, bb.size.y+8, bb.size.z }
                params.callback = callbackName
                params.type = 'ScriptingTrigger'
                params.sound = false
                local zone = spawnObject(params)

                local callbackFunc = function()
                    payoutTable[caller.key][2] = searchContainer(zone.getObjects(), caller, payoutTable[caller.key][2])
                    waitFlags[caller.key] = true
                    zone.destruct()
                end
                Global.setVar(callbackName, callbackFunc)
            end


        --tabulate shares on other companies

        if caller.COMPANIES_CAN_CROSS_INVEST then
            for k,v in pairs(gameEntities.COMPANIES) do
                if k~=caller.key and v.COMPANIES_CAN_OWN_OTHER_SHARES and v.HAS_CHARTER then
                    payoutTable[k] = {v,0}
                    waitFlags[k] = false

                    --Dynamically spawn a scripting zone to on the charter
                    local bb = getObjectFromGUID(v.charterGUID).getBoundsNormalized()
                    local params = {}
                    local callbackName = "callback" .. k
                    params.position = getObjectFromGUID(v.charterGUID).getPosition()
                    params.rotation = getObjectFromGUID(v.charterGUID).getRotation()
                    params.scale = { bb.size.x, bb.size.y+8, bb.size.z }
                    params.callback = callbackName
                    params.type = 'ScriptingTrigger'
                    params.sound = false
                    local zone = spawnObject(params)

                    local callbackFunc = function()
                        payoutTable[k][2] = searchContainer(zone.getObjects(), caller, payoutTable[k][2])
                        waitFlags[k] = true
                        zone.destruct()
                    end
                    Global.setVar(callbackName, callbackFunc)
                end
            end
        end

    end

            Wait.condition(
            function()
                transferPayouts(caller, payoutTable, amount)
            end,
            function()
                local temp = true
                for k,v in pairs(waitFlags) do
                    temp = temp and v
                end
                return temp
            end)
end

function transferPayouts(caller, payoutTable, amount)
    printToAll("--- " .. caller.NAME .. " pays out " .. formatLabel(amount) .. " ---")
    logTransaction(amount, 'Bank', caller.NAME .. ' Shares', false, true)

    if caller.PROPORTIONAL_PAYOUTS then transferPropPayouts(caller, payoutTable, amount) return end
    if caller.COMPANIES_PAY_FLAT_RATE then transferFlatPayouts(caller, payoutTable, amount) return end

    local someoneGotPaid = false
    for k,v in pairs(payoutTable) do
        if (v[2]~=0) then
            someoneGotPaid = true
            local calc = 0
            local string = ''
            if caller.SHARE_DESCRIPTIONS_ARE_PERCENTAGE then
                calc = math.ceil(amount*v[2]/100)
                string = v[1].NAME .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. '%.'
            else
                calc = math.ceil(amount*v[2]/caller.issueSize)
                string = v[1].NAME .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. ' shares (' .. v[2]*100/caller.issueSize .. '%).'
            end
            transferMoneyWithBank(v[1], calc, false, false)
            printToAll(string)
        end
    end
    if not someoneGotPaid then broadcastToAll('No company or player was paid dividends. Make sure shares are where they should be.') end
end

function transferPropPayouts(caller, payoutTable, amount)
    local someoneGotPaid = false
    local allOne = true
    local shareCount = 0
    local perShare = 0
    local remainder = 0
    for k,v in pairs(payoutTable) do
        if (shareCount~=0 and v[2]~=0) then allOne = false end
        shareCount = shareCount + v[2]
    end
    perShare = math.floor(amount/shareCount)
    remainder = amount - shareCount*perShare

    for k,v in pairs(payoutTable) do
        local calc = 0
        if (v[2]~=0) then
            if allOne then
                calc = amount
            else
                calc = v[2]*perShare
            end
            string = v[1].NAME .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. ' shares (' .. v[2] .. '/' .. shareCount .. ')'
            transferMoneyWithBank(v[1], calc, false, false)
            printToAll(string)
        end
    end
    if not allOne then Withhold(caller, remainder) end
end

function transferFlatPayouts(caller, payoutTable, amount)
    local someoneGotPaid = false
        for k,v in pairs(payoutTable) do
            if (v[2]~=0) then
                someoneGotPaid = true
                local calc = 0
                local string = ''
                if caller.SHARE_DESCRIPTIONS_ARE_PERCENTAGE then
                    calc = math.ceil(amount*v[2]/10)
                    string = v[1].NAME .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. '%.'
                else
                    calc = math.ceil(amount*v[2])
                    string = v[1].NAME .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. ' shares.'
                end
                transferMoneyWithBank(v[1], calc, false, false)
                printToAll(string)
            end
        end
        if not someoneGotPaid then broadcastToAll('No company or player was paid dividends. Make sure shares are where they should be.') end
end

function payPrivates()
    local fakeCaller = {} --hacky shit so I can use the share search function on privates
    fakeCaller.shareDescription = 'Private'
    local use_gm = gameOptions.PRIVATES_USE_GM_NOTES

    local payoutTable = {}
    --Part of this function spawns ScriptingZones, which take more than one frame to load.
    --The waitFlags are used to make sure all ScriptingZones have loaded and done their thing before continuing.
    local waitFlags = {}

    --tabulate player privates
    for k,v in pairs(gameEntities.PLAYERS) do
        payoutTable[k] = {v, 0}
        --if player has a designated zone, search that for shares matching this company
        if getObjectFromGUID(v.shareZoneGUID) then
            if getObjectFromGUID(v.shareZoneGUID).tag == 'Scripting' then
                payoutTable[k][2] = searchContainer(getObjectFromGUID(v.shareZoneGUID).getObjects(), fakeCaller, payoutTable[k][2], use_gm)
            else

                waitFlags[k] = false

                --Dynamically spawn a scripting zone to on the charter
                local bb = getObjectFromGUID(v.shareZoneGUID).getBoundsNormalized()
                local params = {}
                local callbackName = "callbackPlayer" .. k
                params.position = getObjectFromGUID(v.shareZoneGUID).getPosition()
                params.rotation = getObjectFromGUID(v.shareZoneGUID).getRotation()
                params.scale = { bb.size.x, bb.size.y+8, bb.size.z }
                params.callback = callbackName
                params.type = 'ScriptingTrigger'
                params.sound = false
                local zone = spawnObject(params)

                local callbackFunc = function()
                    payoutTable[k][2] = searchContainer(zone.getObjects(), fakeCaller, payoutTable[k][2], use_gm)
                    waitFlags[k] = true
                    zone.destruct()
                end
                Global.setVar(callbackName, callbackFunc)

            end
        end
        --search the player's hand
        if gameOptions.HAND_SHARES_PAY_PLAYER then
            payoutTable[k][2] = searchContainer(Player[k].getHandObjects(), fakeCaller, payoutTable[k][2], use_gm)
        end
    end

    --tabulate company privates
    for k,v in pairs(gameEntities.COMPANIES) do
        if v.COMPANIES_CAN_OWN_PRIVATES and v.USE_PRIVATES then
            payoutTable[k] = {v,0}
            waitFlags[k] = false

            --Dynamically spawn a scripting zone to on the charter
            local bb = getObjectFromGUID(v.charterGUID).getBoundsNormalized()
            local params = {}
            local callbackName = "callback" .. k .. "private"
            params.position = getObjectFromGUID(v.charterGUID).getPosition()
            params.rotation = getObjectFromGUID(v.charterGUID).getRotation()
            params.scale = { bb.size.x, bb.size.y+8, bb.size.z }
            params.callback = callbackName
            params.type = 'ScriptingTrigger'
            params.sound = false
            local zone = spawnObject(params)

            local callbackFunc = function()
                payoutTable[k][2] = searchContainer(zone.getObjects(), fakeCaller, payoutTable[k][2], use_gm)
                waitFlags[k] = true
                zone.destruct()
            end
            Global.setVar(callbackName, callbackFunc)
        end
    end

    Wait.condition(
    function()
        transferPrivatePayouts(payoutTable)
    end,
    function()
        local temp = true
        for k,v in pairs(waitFlags) do
            temp = temp and v
        end
        return temp
    end)
end

function transferPrivatePayouts(payoutTable)
    printToAll("--- Privates pay out ---")
    local someoneGotPaid = false
    for k,v in pairs(payoutTable) do
        if (v[2]~=0) then
            transferMoneyWithBank(v[1], v[2], false, false)
            printToAll(v[1].NAME .. ' paid ' .. formatLabel(v[2]) .. ' for Privates')
            someoneGotPaid = true
        end
    end
    if not someoneGotPaid then broadcastToAll('No company or player was paid revenue. Make sure private companies are where they should be.') end
end

function searchContainer(container, caller, count, gm)
    if gm then return searchContainerGM(container, caller, count) end

    --this only works if container is a literal list of object values
    for i,o in ipairs(container) do
        if o.getQuantity() == -1 then
            --object is a singleton
            count = addShare(o.getDescription(),caller,count)
        else
            --object is a deck, or maybe not because getQuanity works for stacks but getObjects does not.
            if o.tag=='Deck' then
                for j,k in ipairs(o.getObjects()) do
                    count = addShare(k.description,caller,count)
                end
            end
        end
    end
    return count
end

function searchContainerGM(container, caller, count)
    --same as above but with GM notes
    --this only works if container is a literal list of object values
    for i,o in ipairs(container) do
        if o.getQuantity() == -1 then
            --object is a singleton
            count = addShare(o.getGMNotes(),caller,count)
        else
            --object is a deck, or maybe not because getQuanity works for stacks but getObjects does not.
            if o.tag=='Deck' then
                for j,k in ipairs(o.getObjects()) do
                    count = addShare(k.gm_notes,caller,count)
                end
            end
        end
    end
    return count
end

function addShare(description, caller, count)
    --if description includes the caller's expected description then add to num
    if (string.find(description, caller.shareDescription)) then
        local num = tonumber(string.sub(description, 1+#caller.shareDescription))
        if num ~= nil then
            return (count + num)
        end
    end
    return count
end

---MISC. HELPER FUNCTIONS---

function changeSize(company)
    company.issueIndex = incLoop(company.issueIndex,#company.ISSUE_SIZE)
    company.issueSize = company.ISSUE_SIZE[company.issueIndex]
    if (type(company.HALF_PAY_ROUND) == 'table') then
        company.halfPayRound = company.HALF_PAY_ROUND[company.issueIndex]
    end
    getObjectFromGUID(company.inputCounterGUID).editButton({index=company.changeSizeButtonIndex, label=company.ISSUE_SIZE[company.issueIndex]..'-Share',})
end

function incLoop(input,max)
    --returns input+1 unless input+1 > max, in which case return 1.
    --good for looping through tables with numbered indicies.
    if input+1 > max then
        return 1
    else
        return input+1
    end
end

function logTransaction(amount, source, target, print, log)
    local str = os.date("%H:%M - ") .. 'Transferred ' .. formatLabel(amount) .. ' from ' .. source .. ' to ' .. target
    if print then
        printToAll(str)
    end

    if TRANSACTION_LOG and log then
        --nested tables?
        TRANSACTIONS = { next = TRANSACTIONS, value = str }
        local t = TRANSACTIONS
        local item = 0
        local transactionLog = ''
        while t and item < 9 do
            transactionLog = transactionLog .. t.value .. '\n'
            item = item + 1
            t = t.next
        end
        TRANSACTION_LOG.setDescription(transactionLog)
    end
end

function updateLabel(table_entry)
    if not table_entry.moneyLabelGUID then return end
    local label = getObjectFromGUID(table_entry.moneyLabelGUID)
    local button_parameters = {}
    button_parameters.click_function = 'nilFunction'
    button_parameters.label = formatLabel(table_entry.treasury)
    button_parameters.position = {0, 0.11, 0}
    button_parameters.rotation = {0, 0, 0}
    button_parameters.width = 0
    button_parameters.height = 0
    button_parameters.font_size = 700
    local s = label.getScale()
    local larger = math.max(s.x,s.z)
    button_parameters.scale = {larger/s.x,1,larger/s.z}
    getObjectFromGUID(table_entry.moneyLabelGUID).clearButtons()
    getObjectFromGUID(table_entry.moneyLabelGUID).createButton(button_parameters)
end

function formatLabel(number)
    local newLabel = format_int(number)
    if gameOptions.MONEY_SYMBOL then
        if gameOptions.MONEY_SYMBOL_POSITION == 'end' then
            newLabel = newLabel .. gameOptions.MONEY_SYMBOL
        else
            newLabel = gameOptions.MONEY_SYMBOL .. newLabel
        end
    end
    return newLabel
end

function format_int(number)
  local i, j, minus, int, fraction = tostring(number):find('([-]?)(%d+)([.]?%d*)')
  -- reverse the int-string and append a comma to all blocks of 3 digits
  int = int:reverse():gsub("(%d%d%d)", "%1,")
  -- reverse the int-string back remove an optional comma and put the
  -- optional minus and fractional part back
  return minus .. int:reverse():gsub("^,", "") .. fraction
end

function addv(v1, v2)
    --add vectors
    return {v1[1]+v2[1], v1[2]+v2[2], v1[3]+v2[3]}
end

function roundTo(input, roundAmount, upDown)
    --returns input rounded to roundAmount
    --if upDown = true, round up, else round down
    if upDown then
        return math.ceil(input / roundAmount) * roundAmount
    else
        return math.floor(input / roundAmount) * roundAmount
    end
end

function onPlayerChangeColor(color)
    if gameEntities.PLAYERS[color] then gameEntities.PLAYERS[color].NAME = Player[color].steam_name end
end

-- event functions ---

function onObjectDrop(_, obj)
    if gameEntities.OTHER_ACTORS.REVENUE_TRACKER then
        if #obj.getDescription() > 30 then return end
        if (string.find(obj.getDescription(), "Revenue")) or (string.find(obj.getDescription(), "revenue")) or (string.find(obj.getDescription(), "REVENUE")) then
            local str = obj.getDescription()

            --I don't know anything about string functions, this should remove the word "revenue" and any excess spaces
            --But leave the spaces within the company name alone.
            --Unless user put a company name that has spaces, like, at the end of it e.g., 'B&O    ' but then the user is a moron so screw them.
            str = string.gsub(str, "^%s*(.-)%s*$", "%1")
            str = string.sub(str,1,-8)
            str = string.gsub(str, "^%s*(.-)%s*$", "%1")

            --check if remaining string corresponds to a company.
            if gameEntities.COMPANIES[str] ~= nil then
                --set the token to not sticky, so it doesn't lift other tokens with it when grabbed.
                obj.sticky = false

                --check is object was dropped within the revenue tracker.
                local pos = obj.getPosition()
                for _,b in ipairs(gameEntities.OTHER_ACTORS.REVENUE_TRACKER) do
                    if b.valid then
                        if pos.x >= b.upperleft.x and pos.x<= b.lowerright.x and pos.z <= b.upperleft.z and pos.z >= b.lowerright.z then
                            --find x-cell
                            local xcell = math.floor( (math.abs(pos.x-b.upperleft.x)/b.width)*b.COLS )
                            local zcell = math.floor( (math.abs(pos.z-b.upperleft.z)/b.height)*b.ROWS )

                            --snap to grid
                            obj.setPositionSmooth({b.upperleft.x + b.cellWidth*(xcell+0.5), pos.y, b.upperleft.z - b.cellHeight*(zcell+0.5)}, false, true)

                            --set counter based on grid position
                            local company = gameEntities.COMPANIES[str]
                            company['revenueTrackerGUID'] = obj.getGUID()
                            local input = getObjectFromGUID(company.inputCounterGUID)

                            local val = b.START + xcell + b.VERTICAL_INC*zcell
                            if company.ADJUST_INPUT_BY_REVENUE then
                                if company.TRACK_REVENUE_PER_SHARE then
                                    input.setValue(val*company.issueSize)
                                else
                                    input.setValue(val*10)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

---Hardcoded values---

ERROR_COLOR = {r=1, g=0, b=0}

bankTransferParams = {}
bankTransferParams.label = 'Spend Money'
bankTransferParams.position = {0.45,0.1,0.5}
bankTransferParams.rotation = {0,180,0}
bankTransferParams.width = 400
bankTransferParams.height = 100
bankTransferParams.font_size = 50
bankTransferParams.tooltip = 'Send money to the bank'

withholdParams = {}
withholdParams.label = 'Take Money'
withholdParams.position = {-0.45,0.1,0.5}
withholdParams.rotation = {0,180,0}
withholdParams.width = 400
withholdParams.height = 100
withholdParams.font_size = 50
withholdParams.tooltip = 'Take money from the bank'

payFullParams = {}
payFullParams.label = 'Payout'
payFullParams.position = {-1,0.1,0}
payFullParams.rotation = {0,180,0}
payFullParams.width = 400
payFullParams.height = 100
payFullParams.font_size = 50

payHalfParams = {}
payHalfParams.label = 'Pay Half'
payHalfParams.position = {-1,0.1, 0}
payHalfParams.rotation = {0,180,0}
payHalfParams.width = 400
payHalfParams.height = 100
payHalfParams.font_size = 50

payPrivatesParams = {}
payPrivatesParams.label = 'Pay Privates'
payPrivatesParams.click_function = 'payPrivates'
payPrivatesParams.position = {0,0.25,0}
payPrivatesParams.width = 1600
payPrivatesParams.height = 450
payPrivatesParams.font_size = 225

changeSizeParams = {}
changeSizeParams.label = 'filler, set by code'
changeSizeParams.position = {1,0.1, 0}
changeSizeParams.rotation = {0,180,0}
changeSizeParams.width = 400
changeSizeParams.height = 100
changeSizeParams.font_size = 75
changeSizeParams.tooltip = 'Click here to cycle through issue sizes'
